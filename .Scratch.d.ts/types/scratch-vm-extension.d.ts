/// <reference path="./scratch-vm.d.ts" />
/// <reference path="./scratch-render.d.ts" />
/// <reference path="./vm-types.d.ts/util.d.ts" />

// TW
/// <reference path="./scratch-blocks.d.ts" />
/**
 * Only exists in files generated by the packager.
 *
 * The intended way to use this is:
 * if (typeof scaffolding !== 'undefined') {
 *   // in packager
 * }
 *
 * Outside of the packager, trying to access scaffolding any other way will throw a
 * reference error, not return undefined (TypeScript does not let us type that unfortunately)
 */
declare const scaffolding: unknown | undefined;
/**
 * In desktop app, prompt() returns a Promise. Thus you should always do `await prompt(...)` which
 * will work in all environments.
 */
declare function prompt(
	message?: string,
	_default?: string
): string | null | Promise<string | null>;

declare namespace Scratch {
	// Tringlyman
	let tringlymanExt: {
		[string: string]: Scratch.Extension;
	};

	// TW
	const vm: VM;
	const renderer: RenderWebGL;
	// Permission requests here always return a promise, but the security manager methods themselves
	// can return either a boolean or promise.
	function fetch(url: string, options?: RequestInit): Promise<Response>;
	function canFetch(url: string): Promise<boolean>;
	function openWindow(url: string, features?: string): Promise<Window | null>;
	function canOpenWindow(url: string): Promise<boolean>;
	function redirect(url: string): Promise<void>;
	function canRedirect(url: string): Promise<boolean>;
	function canRecordAudio(): Promise<boolean>;
	function canRecordVideo(): Promise<boolean>;
	function canReadClipboard(): Promise<boolean>;
	function canNotify(): Promise<boolean>;
	function canEmbed(): Promise<boolean>;
	function canDownload(url: string, name: string): Promise<boolean>;
	function download(url: string, name: string): Promise<void>;
	namespace Cast {
		function toNumber(value: unknown): number;
		function toString(value: unknown): string;
		function toBoolean(value: unknown): boolean;
		/**
		 * @returns 0 if a == b, less than 0 if b is greater, greater than 0 if a is greater.
		 * Do not compare to 1 or -1! You must always use === 0, < 0, or > 0.
		 */
		function compare(a: unknown, b: unknown): number;
		/**
		 * @returns all channels 0-255
		 */
		function toRgbColorList(value: unknown): [number, number, number];
		/**
		 * @returns all channels 0-255
		 */
		function toRgbColorObject(value: unknown): {
			r: number;
			g: number;
			b: number;
			a: number;
		};
		/**
		 * note: for compatibility with a Scratch bug this returns false for tab characters ('\t')
		 */
		function isWhiteSpace(value: unknown): boolean;
		function isInt(value: unknown): boolean;
		const LIST_INVALID = "INVALID";
		const LIST_ALL = "ALL";
		function toListIndex(
			index: unknown,
			length: number,
			acceptAll: false
		): number | "INVALID";
		function toListIndex(
			index: unknown,
			length: number,
			acceptAll: true
		): number | "INVALID" | "ALL";
		function toListIndex(
			index: unknown,
			length: number,
			acceptAll: boolean
		): number | "INVALID" | "ALL";
	}
	type TranslatableString =
		| string
		| {
				id?: string;
				default: string;
				description?: string;
		  };
	function translate(
		string: TranslatableString,
		variables?: Record<string, string>
	): string;
	namespace translate {
		function setup(translations: Record<string, Record<string, string>>): void;
		/** Current language. May change while the project runs. Possible values: "en", "es", "it", etc. */
		let language: string;
	}
	/**
	 * Only available when run in a scratch-gui environment (website, desktop app).
	 * In other environments (packager), will be undefined.
	 */
	namespace gui {
		/**
		 * Lazily get the internal ScratchBlocks object when it becomes available. It may never be
		 * available if, for example, the user never enters the editor.
		 *
		 * ScratchBlocks becoming available does not necessarily mean the user is in the editor due
		 * to getBlocklyEagerly() also existing.
		 */
		function getBlockly(): Promise<ScratchBlocks.RealBlockly>;
		/**
		 * Get the internal ScratchBlocks object as soon as possible. This lets you access it even
		 * if the user never enters the editor.
		 *
		 * This method is VERY SLOW and will cause A LOT OF CPU AND NETWORK ACTIVITY because it
		 * downloads and evaluates all of scratch-blocks, a multi-megabyte JavaScript bundle.
		 */
		function getBlocklyEagerly(): Promise<ScratchBlocks.RealBlockly>;
	}
	namespace BlockShape {
		const HEXAGONAL: 1;
		const ROUND: 2;
		const SQUARE: 3;
		const LEAF: 4;
		const PLUS: 5;
		const OCTAGONAL: 6;
		const BUMPED: 7;
		const INDENTED: 8;
		const SCRAPPED: 9;
		const ARROW: 10;
		const TICKET: 11;
	}

	namespace ArgumentAlignment {
		const LEFT = "left";
		const CENTER = "center";
		const RIGHT = "right";
	}

	// Note that the 'B' in the BOOLEAN enums are capitalized in Scratch. It is not a typo in this file.

	namespace ArgumentType {
		// TW
		const SOUND: "sound";
		const COSTUME: "costume";

		const ANGLE: "angle";
		const BOOLEAN: "Boolean";
		const COLOR: "color";
		const IMAGE: "image";
		const MATRIX: "matrix";
		const NOTE: "note";
		const NUMBER: "number";
		const STRING: "string";

		const CUSTOM = "custom";
		const POLYGON = "polygon";
	}

	namespace BlockType {
		// TW
		const LABEL: "label";
		const XML: "xml";

		const BOOLEAN: "Boolean";
		const BUTTON: "button";
		const COMMAND: "command";
		const CONDITIONAL: "conditional";
		const EVENT: "event";
		const HAT: "hat";
		const LOOP: "loop";
		const REPORTER: "reporter";
	}

	namespace TargetType {
		const SPRITE: "sprite";
		const STAGE: "stage";
	}

	// TW
	interface SoundArgument {
		type: "sound";
		shape?: number;
		check?: string | string[];
	}
	interface CostumeArgument {
		type: "costume";
		shape?: number;
		check?: string | string[];
	}

	interface AngleArgument {
		type: "angle";
		shape?: number;
		check?: string | string[];
		/**
		 * Defaults to 0.
		 */
		defaultValue?: string | number;
	}
	interface BooleanArgument {
		type: "Boolean";
		shape?: number;
		check?: string | string[];
	}
	interface ColorArgument {
		type: "color";
		shape?: number;
		check?: string | string[];
		/**
		 * Should be a hex color code. No alpha channel supported. Defaults to random color.
		 */
		defaultValue?: string | number;
	}
	interface NumberArgument {
		type: "number";
		shape?: number;
		check?: string | string[];
		/**
		 * Defaults to 0.
		 */
		defaultValue?: string | number;
		menu?: string;
	}
	interface StringArgument {
		type: "string";
		shape?: number;
		check?: string | string[];
		/**
		 * Defaults to empty string.
		 */
		defaultValue?: string | number;
		menu?: string;
	}
	interface MatrixArgument {
		type: "matrix";
		shape?: number;
		check?: string | string[];
		/**
		 * Should be a 25 character long string of 1s and 0s.
		 * Numbers are technically accepted, but be aware that due to floating point precision, some detail may be lost.
		 * Technically optional, but behaves strangely with no default value.
		 */
		defaultValue?: string | number;
	}
	interface NoteArgument {
		type: "note";
		shape?: number;
		check?: string | string[];
		/**
		 * Defaults to 0 ("C (0)")
		 */
		defaultValue?: string | number;
	}
	interface ImageArgument {
		type: "image";
		shape?: number;
		check?: string | string[];
		dataURI: string;
		/**
		 * Defaults to false.
		 */
		flipRTL?: boolean;
	}

	interface CustomArgument {
		type: "custom";
		shape?: number;
		check?: string | string[];
		id: "id";
	}

	interface PolygonArgument {
		type: "polygon";
		shape?: number;
		check?: string | string[];
		x: number;
		y: number;
	}

	interface FillInArgument {
		fillIn: string;
		shape?: number;
		check?: string | string[];
	}

	type Argument =
		| CostumeArgument
		| SoundArgument
		| AngleArgument
		| BooleanArgument
		| ColorArgument
		| NumberArgument
		| StringArgument
		| MatrixArgument
		| NoteArgument
		| ImageArgument
		| PolygonArgument
		| CustomArgument
		| FillInArgument;

	// TW
	interface LabelBlock extends AbstractBlock {
		blockType: "label";
	}
	interface XMLBlock extends AbstractBlock {
		blockType: "xml";
		xml: string;
	}

	interface AbstractBlock {
		text?: string | string[];
		filter?: Array<"target" | "sprite">;
	}
	interface ExecutableBlock extends AbstractBlock {
		blockShape?: (typeof Scratch.BlockShape)[keyof typeof Scratch.BlockShape];
		opcode: string;
		func?: string;
		arguments?: Record<string, Argument>;
		hideFromPalette?: boolean;
		blockIconURI?: string;
	}
	interface BooleanBlock extends ExecutableBlock {
		blockType: "Boolean";
		canDragDuplicate?: boolean;
		forceOutputType?: string | string[];
	}
	interface ButtonBlock extends ExecutableBlock {
		blockType: "button";
		func?: "MAKE_A_LIST" | "MAKE_A_PROCEDURE" | "MAKE_A_VARIABLE" | string; // TW - can be any string
	}
	interface CommandBlock extends ExecutableBlock {
		blockType: "command";
		/**
		 * Defaults to false.
		 */
		isTerminal?: boolean;
	}
	interface ConditionalBlock extends ExecutableBlock {
		blockType: "conditional";
		/**
		 * Defaults to false.
		 */
		isTerminal?: boolean;
		/**
		 * Defaults to 1.
		 */
		branchCount?: number;
	}
	interface EventBlock extends ExecutableBlock {
		blockType: "event";
		/**
		 * This must be explicitly set to false, otherwise the block will not work.
		 * Event blocks cannot be edge activated. Use hat instead.
		 */
		isEdgeActivated: false;
		/**
		 * Defaults to false.
		 */
		shouldRestartExistingThreads?: boolean;
	}
	interface HatBlock extends ExecutableBlock {
		blockType: "hat";
		/**
		 * Defaults to true.
		 */
		isEdgeActivated?: boolean;
		/**
		 * Defaults to false.
		 */
		shouldRestartExistingThreads?: boolean;
	}
	interface ReporterBlock extends ExecutableBlock {
		blockType: "reporter";
		/**
		 * Defaults to false.
		 */
		disableMonitor?: boolean;
		canDragDuplicate?: boolean;
		forceOutputType?: string | string[];
	}
	interface LoopBlock extends ExecutableBlock {
		blockType: "loop";
		/**
		 * Defaults to false.
		 */
		isTerminal?: boolean;
		/**
		 * Defaults to 1.
		 */
		branchCount?: number;
	}

	type Separator = "---";

	type Block =
		// TW
		| LabelBlock
		| XMLBlock
		| BooleanBlock
		| ButtonBlock
		| CommandBlock
		| ConditionalBlock
		| EventBlock
		| HatBlock
		| ReporterBlock
		| LoopBlock
		| Separator;

	interface Menu {
		isTypeable?: boolean;
		acceptReporters?: boolean;
		variableType?: string;
		/**
		 * A list of static items in the menu, or the name of the dynamic menu function.
		 */
		items:
			| Array<[String, string] | { text: string; value: string } | string>
			| string;
	}

	interface getInfo {
		id: `${string}`;
		name?: string;
		color1?: `#${string}`;
		color2?: `#${string}`;
		color3?: `#${string}`;
		showStatusButton?: boolean;
		blockIconURI?: string;
		menuIconURI?: string;
		isDynamic?: boolean;
		orderBlock?: (blocks: string[]) => string[];
		/**
		 * @deprecated
		 */
		tsShow?: boolean;
		menus?: {
			[String: string]: Menu;
		};
		customFieldTypes?: {
			[String: string]: any;
		};
		docsURI?: string;
		blocks?: Scratch.Block[];
	}

	namespace ExtensionType {
		type getInfo = ReturnType<Extension["getInfo"]>;
		type BlockParam = (args: { [Arg: string]: any }, util: Util) => any;
	}

	class Extension {
		getInfo: () => Scratch.getInfo;
	}
	namespace extensions {
		function register(extensionObject: Extension): void;

		/**
		 * True if the extension is running in PenguinMod, otherwise undefined.
		 */
		const isPenguinMod: undefined | boolean;

		/**
		 * True if the extension is running unsandboxed, otherwise undefined.
		 */
		const unsandboxed: undefined | boolean;
	}
}
